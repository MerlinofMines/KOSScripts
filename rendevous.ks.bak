RUNONCEPATH("0:/output.ks").
RUNONCEPATH("0:/draw.ks").
RUNONCEPATH("0:/maneuver.ks").

SET targetVessel TO vessel("Kerbin Science Orbiter").

//rendevous(targetVessel).

UNTIL FALSE {
	CLEARSCREEN.
	CLEARVECDRAWS().

	LOCAL timeAtApoapsis IS timeAtNextApoapsis(targetVessel).

	LOCAL targetPeriapsisVector IS -positionVectorAt(targetVessel, timeAtApoapsis).

	LOCAL t IS timeofMaximumVectorAngle(targetVessel, timeAtApoapsis, SHIP).

	LOCAL positionVector IS positionVectorAt(SHIP, t).

	PRINT "Time of maximum Vector Angle: " + t.

	drawVector(targetPeriapsisVector, "Periapsis Vector", SHIP:ORBIT:BODY:POSITION).
	drawVector(positionVector, "Maximum Angle", SHIP:ORBIT:BODY:POSITION).

	LOCAL deltaV IS deltaVToChangeApoapsisAt(t, targetVessel:ORBIT:APOAPSIS, SHIP).

    // future orbit properties
    local r2 IS positionVectorAt(SHIP, t):MAG.
    local sma2 is (r2 + BODY:RADIUS + targetVessel:ORBIT:APOAPSIS)/2. // semi major axis target orbit
    local v2 is sqrt((BODY:mu * (2/r2 - 1/sma2 ) ) ).

	LOCAL targetApoapsisProgradeVector IS VelocityAt(targetVessel, timeAtApoapsis):ORBIT.

	LOCAL sourceProgradeVectorAtNewPeriapsis IS VelocityAt(SHIP, t):ORBIT.

	LOCAL neededProgradeVectorAtNewPeriapsis IS -targetApoapsisProgradeVector:NORMALIZED*v2.

	PRINT "Needed Prograde velocity: " + neededProgradeVectorAtNewPeriapsis:MAG.

	LOCAL deltaVector IS neededProgradeVectorAtNewPeriapsis - sourceProgradeVectorAtNewPeriapsis.

	//Need to convert deltaVector to 
	PRINT "Needed Delta V: " + deltaVector:MAG.

	PRINT "Vector: " + deltaVector.

	Local vectorAngleDiff IS VANG(neededProgradeVectorAtNewPeriapsis, sourceProgradeVectorAtNewPeriapsis).

	//Let's try out this shnazzy eq.
	LOCAL argOfPerDeltaV IS 2*sqrt(BODY:MU / (sma2*(1-SHIP:ORBIT:ECCENTRICITY^2)))*sin(vectorAngleDiff/2).

	PRINT "Vector Angle Diff: " + vectorAngleDiff.
	PRINT "argOfPerDeltaV: " + argOfPerDeltaV.

	PRINT "cos of argOfPerDeltaV: " + cos(vectorAngleDiff)*argOfPerDeltaV.

	PRINT "cosAngle: " + cos(vectorAngleDiff)*cos(vectorAngleDiff)*deltaVector:MAG.
	PRINT "sinAngle: " + sin(vectorAngleDiff)*deltaVector:MAG.

    local n is node(t, argOfPerDeltaV, 0, deltaVector:MAG).

	ADD n.

	break.
}

UNTIL TRUE {
	CLEARSCREEN.
	CLEARVECDRAWS().
	LOCAL pT is timeToPeriapsis(targetVessel).
	LOCAL aT IS timeToApoapsis(targetVessel).

	LOCAL timeAtP IS timeAtNextPeriapsis(targetVessel).
	LOCAL timeAtA IS timeAtNextApoapsis(targetVessel).

	PRINT "Period: " + targetVessel:ORBIT:PERIOD.
	PRINT "Target time to Periapsis: " + pT.
	PRINT "Target time to Apoapsis: " + aT.
	PRINT " ".
	PRINT "Target time at next Periapsis: " + timeAtP.
	PRINT "Target time at next Apoapsis: " + timeAtA.

	LOCAL targetPositionAtApoapsis IS positionVectorAt(targetVessel, timeAtA).
	LOCAL targetPositionAtPeriapsis IS positionVectorAt(targetVessel, timeAtP).

//	drawVector(targetPositionAtPeriapsis, "Target Periapsis Position", targetVessel:ORBIT:BODY:POSITION).
//	drawVector(targetPositionAtApoapsis, "Target Apoapsis Position", targetVessel:ORBIT:BODY:POSITION).

	drawVector(targetPositionAtApoapsis:NORMALIZED*(targetPositionAtApoapsis:MAG + targetPositionAtPeriapsis:MAG), "Target Apoapsis Position", targetPositionAtPeriapsis + targetVessel:ORBIT:BODY:POSITION).

	WAIT 0.05.
}

UNTIL TRUE {
	CLEARSCREEN.
	CLEARVECDRAWS().
	
	LOCAL minimumSeparationTime IS timeOfMinimumInterceptionSeparation(targetVessel).
//	LOCAL minimumSeparationTime IS TIME:SECONDS.

	PRINT "minimumSeparationTime: " + minimumSeparationTime.
	PRINT "minimumSeparationDistance: " + separationDistanceAtTime(SHIP, targetVessel, minimumSeparationTime).

//	PRINT "Source Vessel Position: " + sourceVesselPosition.
//	PRINT "Target Vessel Position: " + targetVesselPosition.

	LOCAL sourceVesselPosition IS POSITIONAT(SHIP, minimumSeparationTime).
	LOCAL targetVesselPosition IS POSITIONAT(targetVessel, minimumSeparationTime).

	drawVector(sourceVesselPosition, "SourcePosition").
	drawVector(targetVesselPosition, "TargetPosition").

	WAIT 0.1.
}

function rendevous {
	parameter targetVessel.

	matchInclination(targetVessel).
	hohmannTransfer(targetVessel).
}

//This function assumes that you have already performed an inclination change and the targetVessel is in the
//same plane as SHIP. 
function hohmannTransfer {
	parameter targetVessel.

	//The first step here is to figure out when to burn to apoapsis.  We have a choice here.  We can either immediately
	//Burn up to apoapsis and then calculate our expected separation distance, or we can figure out the optimal time
	//to Burn up to apoapsis

	//Note, how do we hohman transfer to a lower orbit? Would be nice to handle that in this method as well.

	//Step 1: Identify the point in time to burn prograde (or possibly retrograde) in order raise (or possibly lower) our apoapsis to intersect nicely with the apoapsis of our target.  For highly eccentric orbits this will not result in an efficient transfer, but for most circular orbits this isn't as big a factor, and makes the next step simple, as we now have a well known point of minimum intersection at which we can burn prograde to synchronize the orbital periods to force a rendevous
	//using our target's (and so by our) apoapsis.

	LOCAL targetTimeAtApoapsis IS timeAtNextApoapsis(targetVessel).

	LOCAL targetPositionAtApoapsis IS positionVectorAt(targetVessel, targetTimeAtApoapsis).

	drawVector(targetPositionAtApoapsis, "Target Apoapsis Position", targetVessel:ORBIT:BODY:POSITION).

 	LOCAL timeOppositeToTargetApoapsis IS timeofMaximumVectorAngle(targetVessel, targetTimeAtApoapsis, SHIP).
	
	//Step 2: Now we need to burn in the correct direction to raise our apoapsis
	LOCAL n IS changeApoapsisAt(timeOppositeToTargetApoapsis, targetVessel:ORBIT:APOAPSIS, SHIP).

	ADD n.

	//Step 3: Raise our Apoapsis to target Apoapsis.
//	Local maneuver IS changeApoapsis(targetVessel:APOAPSIS).
//	ADD maneuver.
//	executeNextManeuver().
}




function deltaVToChangeApoapsisAt {
    parameter newPeriapsisTime.
    parameter newApoapsis.
    parameter sourceVessel IS SHIP.

    local mu is body:mu.
    local br is body:radius.

    // present orbit properties
    local vom is velocity:orbit:mag.               // actual velocity
    local r is br + altitude.                      // actual distance to body

    local v1 IS VelocityAt(sourceVessel, newPeriapsisTime):ORBIT:MAG. //velocity at new burn periapsis
    local sma1 is (periapsis + 2*br + apoapsis)/2. // semi major axis present orbit

    PRINT "r: " + r.
    PRINT "sma1: " + sma1.
    PRINT "Known Sma1: " + ship:ORBIT:SEMIMAJORAXIS.
    PRINT "Vom: " + vom.
    PRINT "MU: " + mu.

    // future orbit properties
    local r2 IS positionVectorAt(sourceVessel, newPeriapsisTime):MAG.
    local sma2 is (r2 + br + newApoapsis)/2. // semi major axis target orbit
    local v2 is sqrt((mu * (2/r2 - 1/sma2 ) ) ).

    PRINT "r2: " + r2.
    PRINT "sma2: " + sma2.
    PRINT  "V2: " + v2.
    PRINT "VOM ^ 2: " + vom^2.

    PRINT "Other Stuff: " + (2/r2 - 1/sma2 ).
    PRINT "Other Stuff * mu: " + (2/r2 - 1/sma2 ) * mu.

    // create node
    local deltav is v2 - v1.

    return deltaV.
}

//Warning, this function assumes the two vessels are currently orbiting the same body.
function timeOfMinimumInterceptionSeparation {
	parameter targetVessel.
	parameter sourceVessel IS SHIP.	

	LOCAL startTime IS TIME:SECONDS.
	LOCAL stepNumber IS 30.
	LOCAL stepDuration IS SHIP:ORBIT:PERIOD / stepNumber.

	LOCAL minimumSeparationTime IS timeOfMinimumInterceptionSeparationIterate(sourceVessel, targetVessel, startTime, stepNumber, stepDuration).

	return minimumSeparationTime.
}

//Returns the point in time at which the angle between source vessel's position vector (see positionVectorAt())
//and the target vessel's position vector (assumed to be at a specific known point in time/space, such as it's apoapsis)
//is at a minimum.  
//
//This function is very useful for determining the point in time that a rendevous burn to synchronize the periods
//of an orbit should take place, assuming that the vessels were previously placed in to orbits such that their intersection is
//at a minimum at a known point in time/space, such as at the source or target's apoapsis or periapsis.
//
//Note: this function assumes the source and target vessels are orbiting roughly in the same plane.
function timeofMinimumVectorAngle {
	
}

//Returns the point in time at which the angle between source vessel's position vector (see positionVectorAt())
//and the target vessel's position vector (assumed to be at a specific known point in time/space, such as it's apoapsis)
//is at a maximum.
//
//This function is very useful for determining the point in time that a burn to minimize the intersection distance at a known point in time/space.  For example, this method might tell you the exact time that you should burn prograde such that your new apoapsis will intersect with your target's apoapsis, making it much easier to perform a rendevous (as you would now know that you need to burn at apoapsis to synchronize your periods to create a rendevous).
//
//Note: this function assumes the source and target vessels are orbiting roughly in the same plane.
function timeofMaximumVectorAngle {
	parameter targetVessel.
	parameter pointInTime.
	parameter sourceVessel IS SHIP.

	LOCAL positionVectorAtTime IS positionVectorAt(targetVessel, pointInTime).

	LOCAL startTime IS TIME:SECONDS.
	LOCAL stepNumber IS 3.
	LOCAL stepDuration IS SHIP:ORBIT:PERIOD / stepNumber.

	LOCAL maximumVectorAngleTime IS timeofMaximumVectorAngleIterate(positionVectorAtTime, sourceVessel, startTime, stepNumber, stepDuration).

	return maximumVectorAngleTime.
}

function timeofMaximumVectorAngleIterate {
	parameter positionVector.
	parameter sourceVessel.			
	parameter startTime.
	parameter stepNumber.
	parameter stepDuration.
	parameter errorBound IS 0.01. //Error bound, in seconds.
	parameter iterationCount IS 1.

	LOCAL maximumVectorAngle IS VANG(positionVector, positionVectorAt(sourceVessel, startTime)).
	LOCAL maximumVectorAngleTime IS startTime.

	FROM {LOCAL step IS 1.} UNTIL step >= stepNumber STEP {SET step TO step + 1.} DO {
//		PRINT "Step is: " + step.
		LOCAL vectorAngleTime iS startTime + (step * stepDuration).

//		PRINT "Vector Angle Time is: " + vectorAngleTime.

		LOCAL vesselPosition IS positionVectorAt(sourceVessel, vectorAngleTime).

//		drawVector(positionVector, "TestPosition." + step, sourceVessel:ORBIT:BODY:POSITION).

		LOCAL newMaximumVectorAngle IS VANG(vesselPosition, positionVector).

		IF (newMaximumVectorAngle > maximumVectorAngle) {
			SET maximumVectorAngle TO newMaximumVectorAngle.
			SET maximumVectorAngleTime TO vectorAngleTime.
		}
	}

	if(stepDuration < errorBound) {
		PRINT "Achieved requested result in " + iterationCount + " iterations".
		PRINT "Step Duration: " + stepDuration.
		PRINT "MaximumVectorAngle: " + maximumVectorAngle.
		return maximumVectorAngleTime.
	}

//	drawVector(positionVectorAt(sourceVessel, maximumVectorAngleTime), "Iteraction." + iterationCount, sourceVessel:ORBIT:BODY:POSITION).

	LOCAL newStartTime IS maximumVectorAngleTime - stepDuration.
	LOCAL newStepDuration TO (stepDuration * 2) / stepNumber.

	LOCAL revisedMaximVectorAngleTime TO timeofMaximumVectorAngleIterate(positionVector, sourceVessel, newStartTime, stepNumber, newStepDuration, errorBound, iterationCount+1).

	return revisedMaximVectorAngleTime.
}

//Returns the next instant in time that the source vessel will be at its orbital apoapsis.
function timeAtNextApoapsis {
	parameter sourceVessel.

	return timeToApoapsis(sourceVessel) + TIME:SECONDS.
}

//Returns the next instant in time that the source vessel will be at its orbital periapsis.
function timeAtNextPeriapsis {
	parameter sourceVessel.

	return timeToPeriapsis(sourceVessel) + TIME:SECONDS.
}

//Returns the seconds until the source vessel will be at its orbital periapsis.  To get the actual point in time, add Time:SECONDS.
//Uses time equation
function timeToPeriapsis {
	parameter sourceVessel.
	return timeToOrbitRevolutionsFromLastPeriapsis(sourceVessel, 1).//1 revolution from last periapsis will be the next time we're at periapsis.
}


//Returns the seconds until the source vessel will be at its orbital apoapsis.  To get the actual point in time, add Time:SECONDS.
//Uses time equation
function timeToApoapsis {
	parameter sourceVessel.
	LOCAL timeToNextApoapsis IS timeToOrbitRevolutionsFromLastPeriapsis(sourceVessel, 0.5).//Half a revolution will be at apoapsis.

	//It's possible that we already passed apoapsis since last periapsis (we're currently on our way towards periapsis)
	IF timeToNextApoapsis < 0 {
		SET timeToNextApoapsis TO timeToNextApoapsis + sourceVessel:ORBIT:PERIOD.
	}

	return timeToNextApoapsis.
}

//Returns the time in seconds until the source vessel goes through the given revolutions
//through it's orbit.  This parameter can be a decimal, and can be used to get the next time
//to periapsis (revolutions = 1), next Apoapsis ()
function timeToOrbitRevolutionsFromLastPeriapsis {
	parameter sourceVessel.
	parameter revolutions.

	LOCAL a iS sourceVessel:ORBIT:SEMIMAJORAXIS.
	LOCAL mu IS sourceVessel:ORBIT:BODY:MU.
	LOCAL e IS sourceVessel:ORBIT:ECCENTRICITY.
	LOCAL v is sourceVessel:ORBIT:TRUEANOMALY.
	LOCAL tau IS eccentricAnomalyFromTrueAnomaly(v, e).
	LOCAL period IS sourceVessel:ORBIT:PERIOD.

	LOCAL t IS sqrt(a*a*a/mu)*(CONSTANT:DegToRad*tau - e*sin(tau)).

//	PRINT "t is: " + t.
//	PRINT "True Anomaly: " + v.

	LOCAL timeSinceLastPeriapsis IS (period - t).

//	PRINT "Period: " + period.
//	PRINT "Revolutions: " + revolutions.
//	PRINT "timeSinceLastPeriapsis Before negative: " + timeSinceLastPeriapsis.

	//If we're on our way towards periapsis, then we our eccentric anomaly is not quite right. Compensate.
	IF (v < 180) {
		SET timeSinceLastPeriapsis TO period - timeSinceLastPeriapsis.
	}

//	PRINT "timeSinceLastPeriapsis Before revolutions: " + timeSinceLastPeriapsis.


	return revolutions*period - timeSinceLastPeriapsis.	
}


function eccentricAnomalyFromTrueAnomaly {
	parameter trueAnomaly.
	parameter eccentricity.

	LOCAL cosE IS (eccentricity + cos(trueAnomaly)) / (1 + (eccentricity * cos(trueAnomaly))).

//	PRINT "cosE: " + cosE.

	return arccos(cosE).
}


function positionVectorAt {
	parameter sourceVessel.
	parameter time.

	return POSITIONAT(sourceVessel, time) - sourceVessel:ORBIT:BODY:POSITION.
}

//Warning, this function assumes the two vessels are currently orbiting the same body.
function timeOfMinimumInterceptionSeparationIterate {
	parameter sourceVessel.
	parameter targetVessel.
	parameter startTime.
	parameter stepNumber.
	parameter stepDuration.

	LOCAL closestSeparationDistance IS 10000000000000000.
	LOCAL closestSeparationTime IS startTime.

	FROM {LOCAL step IS 1.} UNTIL step >= stepNumber STEP {SET step TO step + 1.} DO {
//		PRINT "Step is: " + step.
		LOCAL separationTime iS startTime + (step * stepDuration).

//		PRINT "Separation Time is: " + separationTime.

		LOCAL sourceVesselPosition IS positionVectorAt(sourceVessel, separationTime).
		LOCAL targetVesselPosition IS positionVectorAt(targetVessel, separationTime).

//		drawVector(sourceVesselPosition, "SourcePosition." + step, sourceVessel:ORBIT:BODY:POSITION).
//		drawVector(targetVesselPosition, "TargetPosition." + step, sourceVessel:ORBIT:BODY:POSITION).

		LOCAL ignore IS FALSE.

		//If the source vessel is above or below the orbit of target at this point, it can't possibly be an intersection.
		if (sourceVesselPosition:MAG < (BODY:RADIUS + targetVessel:ORBIT:PERIAPSIS)) {
//			PRINT "Below Periapsis of Target, ignoring".
			SET ignore TO TRUE.
		}

		if (sourceVesselPosition:MAG > (BODY:RADIUS + targetVessel:ORBIT:APOAPSIS)) {
//			PRINT "Above Apoapsis of Target, ignoring".
			SET ignore TO TRUE.
		}

	//	PRINT "Source Vessel Position: " + sourceVesselPosition.
	//	PRINT "Target Vessel Position: " + targetVesselPosition.

		LOCAL newClosestSeparationDistance IS  (sourceVesselPosition - targetVesselPosition):MAG.

		IF (newClosestSeparationDistance < closestSeparationDistance AND NOT ignore) {
			SET closestSeparationDistance TO newClosestSeparationDistance.
			SET closestSeparationTime TO separationTime.
		}
	}

	return closestSeparationTime.
}


function separationDistanceAtTime {
	parameter sourceVessel.
	parameter targetVessel.
	parameter specificTime.

	LOCAL sourceVesselPosition IS POSITIONAT(sourceVessel, specificTime).
	LOCAL targetVesselPosition IS POSITIONAT(targetVessel, specificTime).

//	PRINT "Source Vessel Position: " + sourceVesselPosition.
//	PRINT "Target Vessel Position: " + targetVesselPosition.

//	drawVector(sourceVesselPosition, "SourcePosition").
//	drawVector(targetVesselPosition, "TargetPosition").

	return (sourceVesselPosition - targetVesselPosition):MAG.
}

//This function will always burn at the next "ascending node" to match the inclination of the target vessel.
//It will recursively call itself until the final inclination is < 0.01.
//Note: This functio needs some work.  Calculation of the eccentricity vector is off, and is likely affecting
//The calculation of the ascending node location (leading to a pre-burn, which means we have to iterate).
//Furthermore, a smarter algorithm for the inclination burn may help accomplish the plane change with 1 burn and remove
//the need to recurse.
function matchInclination {
	parameter targetVessel.

	LOCAL relativeInc IS relativeInclination(targetVessel:ORBIT).

	if (relativeInc < 0.01) {
		PRINT "Inclination Change Complete.".
		PRINT "Final Relative Inclination: " + relativeInclination(targetVessel:ORBIT).
		return.
	}

	SAS ON.
	SET SASMODE TO "ANTINORMAL". 

	LOCAL shipOrbitalVelocity IS SHIP:ORBIT:VELOCITY:ORBIT.
	LOCAL shipOrbitalPosition IS SHIP:ORBIT:BODY:ORBIT:POSITION.

	UNTIL (VANG(SHIP:FACING:FOREVECTOR, VCRS(shipOrbitalVelocity,shipOrbitalPosition)) < 0.1) {
		CLEARSCREEN.
		CLEARVECDRAWS().
		PRINT "Rotating to Anti-Normal in preparation for inclination burn.".
		PRINT "Angle: " + VANG(SHIP:FACING:FOREVECTOR, VCRS(shipOrbitalVelocity,shipOrbitalPosition)).
		drawVector(SHIP:FACING:FOREVECTOR:NORMALIZED*30,"Facing").
		drawVector(VCRS(shipOrbitalVelocity,shipOrbitalPosition)*30,"Normal").

		SET shipOrbitalVelocity TO SHIP:ORBIT:VELOCITY:ORBIT.
		SET shipOrbitalPosition TO SHIP:ORBIT:BODY:ORBIT:POSITION.
	}

	LOCAL timeToBurn IS timeToInclinationBurn(targetVessel).

	IF (timeToBurn - 10 > TIME:SECONDS) {
        WARPTO(timeToBurn - 10).
    }

	UNTIL TIME:SECONDS > timeToBurn {
		CLEARSCREEN.
		Print "Time to Burn: " + (timeToBurn - TIME:SECONDS).
	}

	inclinationBurn(targetVessel).

	//We are recursing as our algorithm isn't quite good enough yet.
	matchInclination(targetVessel).
}

function inclinationBurn {
	parameter targetVessel.

	SET THROTTLE to 1.0.

	LOCAL relI IS 1000.

	SET DONE TO FALSE.

	UNTIL FALSE {
		CLEARSCREEN.
		LOCAL newRelI IS relativeInclination(targetVessel:ORBIT).
		PRINT "Relative Inclination: " + newRelI.
		if(newRelI > relI) {
			BREAK.
		} 

		SET relI TO newRelI.
		WAIT 0.1.
	}

	SET THROTTLE TO 0.0.

//	WAIT UNTIL THROTTLE = 0.
	WAIT 1.

	UNLOCK THROTTLE.

	PRINT "Inclination Burn Complete".
}

function timeToInclinationBurn {
	CLEARSCREEN.
	CLEARVECDRAWS().

	parameter targetVessel.

//	SET TARGET TO targetVessel.

	LOCAL shipOrbitalVelocity IS SHIP:ORBIT:VELOCITY:ORBIT.
	LOCAL shipOrbitalPosition IS -SHIP:ORBIT:BODY:ORBIT:POSITION.

	LOCAL targetOrbitalVelocity IS targetVessel:ORBIT:VELOCITY:ORBIT.
	LOCAL targetOrbitalPosition IS (targetVessel:ORBIT:POSITION - targetVessel:ORBIT:BODY:ORBIT:POSITION).

//	PRINT shipOrbitalVelocity.
//	PRINT shipOrbitalPosition.

	LOCAL shipOrbitalMomentum IS VCRS(shipOrbitalPosition, shipOrbitalVelocity).
//	drawVector(shipOrbitalPosition, "Position").
//	drawVector(shipOrbitalVelocity,"Velocity").
//	drawVector(shipOrbitalMomentum,"Momentum").

//	PRINT "Ship Orbital Momentum: " + shipOrbitalMomentum.

	LOCAL targetOrbitalMomentum IS VCRS(targetOrbitalPosition, targetOrbitalVelocity).
//	drawVector(targetOrbitalPosition, "TargetPosition").
//	drawVector(targetOrbitalVelocity,"TargetVelocity").
//	drawVector(targetOrbitalMomentum,"TargetMomentum").

	LOCAL relativeInc IS VANG(shipOrbitalMomentum, targetOrbitalMomentum).
	PRINT "Relative Inclination: " + relativeInc.

	//Ascending or descending node
	LOCAL vectorToAscendingNode IS VCRS(shipOrbitalMomentum, targetOrbitalMomentum).
//	drawVector(vectorToAscendingNode*100000000, "Node", SHIP:ORBIT:BODY:ORBIT:POSITION).

	//The below was taken graciously from the following post:
	//https://www.reddit.com/r/Kos/comments/4hhrld/finding_the_relative_andn/

	//Calculate eccentricity vector.  
	//See this equation: https://en.wikipedia.org/wiki/Eccentricity_vector#Calculation
	LOCAL mu IS CONSTANT:G * SHIP:ORBIT:BODY:MASS.

	LOCAL eccentricityVector IS getEccentricityVector(SHIP).

//  PRINT "mu (G): " + mu.
//  PRINT "Without G: " + VCRS(shipOrbitalVelocity, shipOrbitalMomentum):MAG.
//	PRINT "First: " + (VCRS(shipOrbitalVelocity, shipOrbitalMomentum) / mu):MAG.
//	PRINT "Second: " + (shipOrbitalPosition / shipOrbitalPosition:MAG):MAG.

	//The below should match.
//	PRINT "Eccentricity Vector Magnitude: " + eccentricityVector:MAG.
//	PRINT "Known Eccentricity: " + SHIP:ORBIT:ECCENTRICITY.
//	PRINT "Margin of error: " + (abs(eccentricityVector:MAG - SHIP:ORBIT:ECCENTRICITY)) / SHIP:ORBIT:ECCENTRICITY.

	//Get True Anomaly of Relative Ascending Node.  
	//See this equation: https://en.wikipedia.org/wiki/True_anomaly#From_state_vectors
	LOCAL trueAnomalyNow IS arccos(VDOT(eccentricityVector, shipOrbitalPosition) / (eccentricityVector:MAG * shipOrbitalPosition:MAG)).

	LOCAL trueAnomalyNow IS arccos(VDOT(eccentricityVector, shipOrbitalPosition) / (eccentricityVector:MAG * shipOrbitalPosition:MAG)).

	if (shipOrbitalPosition * shipOrbitalVelocity < 0) {
		SET trueAnomalyNow TO 360 - trueAnomalyNow.
	}

	LOCAL trueAnomalyAscending IS arccos(VDOT(eccentricityVector, vectorToAscendingNode) / (eccentricityVector:MAG * vectorToAscendingNode:MAG)).

//	if (vectorToAscendingNode * shipOrbitalVelocity < 0) {
//		SET trueAnomalyNow TO 360 - trueAnomalyNow.
//	}

//	LOCAL shipTrueAnomaly IS SHIP:ORBIT:TRUEANOMALY.

//	PRINT "Calculated True anomaly: " + trueAnomalyNow.
//	PRINT "Known True Anomaly: " + shipTrueAnomaly.

//	PRINT "True Anomaly of Ascending Node: " + trueAnomalyAscending.

//	PRINT "Margin of Error: " + abs(trueAnomalyNow - shipTrueAnomaly) / shipTrueAnomaly.

	//Get Eccentric Anomaly of Relative Ascending Node
	LOCAL eccentricAnomalyAscending IS eccentricAnomalyFromTrueAnomaly(trueAnomalyAscending, eccentricityVector:MAG).

//	LOCAL cosE IS (eccentricityVector:MAG + cos(trueAnomalyAscending)) /
										(1 + (eccentricityVector:MAG * cos(trueAnomalyAscending))).

//	LOCAL eccentricAnomalyAscending IS arccos(cosE).

	//Get Mean Anomaly Ascending
	LOCAL meanAnomalyAscending IS eccentricAnomalyAscending - eccentricityVector:MAG * sin(eccentricAnomalyAscending).

	//Get Time to Relative Ascending Node from Periapsis
	LOCAL t IS ETA:PERIAPSIS + TIME:SECONDS - SHIP:ORBIT:PERIOD.
	LOCAL n IS 360/SHIP:ORBIT:PERIOD.

	LOCAL timeToAscendingNode IS meanAnomalyAscending/ n + t.

	//Delta V calculation for inclination change, taken from:
	//https://en.wikipedia.org/wiki/Orbital_inclination_change#Calculation

	LOCAL deltaVRequired IS inclinationChangeDeltaV(relativeInc, trueAnomalyAscending).
	LOCAL deltaVRequiredNow IS inclinationChangeDeltaV(relativeInc, SHIP:ORBIT:TRUEANOMALY).

	PRINT "Delta V Required: " + deltaVRequired.
//	PRINT "Delta V Required Now: " + deltaVRequiredNow.

	LOCAL halfBurnTime IS calculatehalfBurnDuration(deltaVRequired).

	info("Half Burn Time: " + halfBurnTime).

	SET timeToAscendingNodeBurn TO timeToAscendingNode - halfBurnTime.

	if (timeToAscendingNodeBurn < TIME:SECONDS) {
		SET timeToAscendingNodeBurn TO timeToAscendingNodeBurn + SHIP:ORBIT:PERIOD.
	}

	return timeToAscendingNodeBurn.
}

function getEccentricityVector {
	parameter sourceVessel.

	//Method 1, which appears to have some innacuracy:
	LOCAL shipOrbitalVelocity IS sourceVessel:ORBIT:VELOCITY:ORBIT.
	LOCAL shipOrbitalPosition IS -sourceVessel:ORBIT:BODY:ORBIT:POSITION.

	LOCAL shipOrbitalMomentum IS VCRS(shipOrbitalPosition, shipOrbitalVelocity).

	LOCAL eccentricityVector IS (VCRS(shipOrbitalVelocity, shipOrbitalMomentum) / sourceVessel:ORBIT:BODY:MU)
								 - (shipOrbitalPosition / shipOrbitalPosition:MAG).

	//Method 2, maybe more accurate?
	LOCAL timeAtP IS timeAtNextPeriapsis(sourceVessel).

	LOCAL positionAtPeriapsis IS positionVectorAt(sourceVessel, timeAtP).

	LOCAL newEccentricityVector IS positionAtPeriapsis:NORMALIZED * sourceVessel:ORBIT:ECCENTRICITY.

	//Let's draw the two and see how they compare.

	LOCAL sourcePeriapsis IS sourceVessel:ORBIT:PERIAPSIS + sourceVessel:ORBIT:BODY:RADIUS.

	PRINT "Periapsis: " + sourcePeriapsis.

	drawVector(eccentricityVector:NORMALIZED*sourcePeriapsis, "Method 1", sourceVessel:ORBIT:BODY:POSITION).
	drawVector(newEccentricityVector:NORMALIZED*sourcePeriapsis, "Method 2", sourceVessel:ORBIT:BODY:POSITION).

	return newEccentricityVector.
}

function inclinationChangeDeltaV {
	parameter inclinationChangeDegrees.
	parameter trueAnomalyAtTime.
	LOCAL e IS SHIP:ORBIT:ECCENTRICITY.
	LOCAL omega IS SHIP:ORBIT:ARGUMENTOFPERIAPSIS.
	LOCAL f IS trueAnomalyAtTime.
	LOCAL n IS 360 / SHIP:ORBIT:PERIOD.
	LOCAL a IS SHIP:ORBIT:SEMIMAJORAXIS.

	PRINT "e: " + e.
	PRINT "omega: " + omega.
	PRINT "f: " + f.
	PRINT "n: " + n.
	PRINT "a: " + a.

//	LOCAL multiplier IS 2*sqrt(1 - (e*e))*cos(omega + f)*n*a / (1 + (SHIP:ORBIT:ECCENTRICITY * cos(f))).
	LOCAL multiplier IS 2 * VELOCITY:ORBIT:MAG.

	return multiplier * sin(inclinationChangeDegrees/2).
}

function relativeInclination {
	parameter targetOrbit.
	parameter sourceOrbit IS SHIP:ORBIT.

	LOCAL shipOrbitalVelocity IS sourceOrbit:VELOCITY:ORBIT.
	LOCAL shipOrbitalPosition IS -sourceOrbit:BODY:ORBIT:POSITION.

	LOCAL targetOrbitalVelocity IS targetOrbit:VELOCITY:ORBIT.
	LOCAL targetOrbitalPosition IS (targetOrbit:POSITION - targetOrbit:BODY:ORBIT:POSITION).

	LOCAL shipOrbitalMomentum IS VCRS(shipOrbitalPosition, shipOrbitalVelocity).
	LOCAL targetOrbitalMomentum IS VCRS(targetOrbitalPosition, targetOrbitalVelocity).
	LOCAL relativeInc IS VANG(shipOrbitalMomentum, targetOrbitalMomentum).

//	PRINT "Relative Inclination: " + relativeInc.
	return relativeInc.
}